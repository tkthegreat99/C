정렬
   데이터들을 순서대로 위치 시키는 것
   ex) 1 5 4 9 0 7
   -> 0 1 4 5 7 9

선택 정렬
   가지고 있는 것들 중 가장 작은 것부터 하나씩 선택
   순서대로 앞에 내려놓는 방식

   1. 가장 앞부터 순서대로 하나씩 선택(이 위치가 가장 작은 값이 위치할 곳)
   2. 선택된 값부터 가장 마지막까지 중 가장 작은 값을 찾음
   3. 찾은 값과 선택된 값을 서로 교환

알고리즘의 평가

   시간복잡도
      입력에 따른 알고리즘의 반복 횟수
      1. 알고리즘의 정확한 반복횟수 계산이 어려움
      2. 아래와 같은 경우 공평하게 계산하기 어려움
      ex) a. for(i=1;i<6;i++)  n번 반복
            printf("!")
            printf("!")
          b. for(i=1;i<10;i++) n번 반복
            printf("!")
         c. for(i=1;i<6;i++)  n번 반복
            printf("!")
            printf("!")
            printf("!")
            printf("!")
            printf("!")
            printf("!")
            printf("!")
            
      *반복문 안에서 수행되는 코드는 무시
      즉 반복 횟수만 평가
      *반복문이 입력값과 관계 없이 반복도 무시
      *모든 반복 횟수는 입력값에 따른 배수로 표현
      *몇 배수인지는 무시

      반복 횟수의 최고차항이 몇 차항 인지만 평가
      반복 횟수가 5*n^3 + n^2 - 120 <=> n^3 번 반복 

표현 방법(notation)
      위와 같은 표현 방법을 Big O notatation 이라 부름
      O(n^3)
      위와 같이, 대문자 O()에서 () 안에 몇 번 반복인지 적음

자주 사용되는 시간 복잡도 형태
   O(1)      : 입력과 무관하게 수행시간이 일정함
   O(log n)   : 입력의 로그로 수행시간이 늘어남
   O(n)      : 입력에 비례하게 수행시간이 늘어남
   O(n log n)  : 입력의 선형로그로 수행시간이 늘어남
   O(n^2)      : 입력의 급수로 수행시간이 늘어남
   O(2^n)      : 지수 형태로 수행시간이 늘어남
   O(n!)       : 펙토리얼 형태(일반적으로 최악)

연습
   a.      for(int i = 0; i< n; i++){
         ...
         }
         시간 복잡도 : O(n)

   b.      for(int i = 0; i < n*10; i++){
         ...
         }
         시간 복잡도 : O(n)

   c.      void func(int n){
         if (n==1) return;
         return func(n-1);
         }
         시간 복잡도 : O(n)

   d.      for(int i = 1; i<n*10;i = i*2){
         ...
         }
         시간 복잡도 : O(log n)

   e.      void func(int n){
         if (n==1) return;
         return func(n/2);
         }
         시간 복잡도 : O(log n)
이진 탐색

   특정 숫자/데이터를 찾을 때 전체 범위 중 중간을 선택해서
   범위를 매번 절반으로 줄여가며 찾는 알고리즘 
   26
   50->25->36->30->27->26

   for(int i = 0 ; i < n; i++){
      for(int j = 0 ; j < n; j++){
      ...
      }
   }
   시간 복잡도 : O(n^2)

   int fibo(int n){
      if(x==1 || x==2) return 1;
      else fibo(n-1) + fibo(n-2);
   }
   시간 복잡도 : O(2^n)

   for(int i = 0 ; i < n; i++){
      res = one + two;
      ont = two;
      two = res;
   }
   시간 복잡도 : O(n)

   1번째 부터 n번째 까지 모든 피보나치 수를 화면에 출력하는 함수
   시간 복잡도 : O(n*n)
*/



#include<stdio.h>

int main() {
   int data[] = { 1, 5, 4, 9, 0, 7 };
   int min;
   int tmp;
   int size = sizeof(data) / sizeof(int);

   for (int i = 0; i < size; i++) {
      min = i;
      for (int j = i; j < size; j++) {
         if (data[min] >= data[j]) {
            min = j;
         }


      }
      tmp = data[i];
      data[i] = data[min];
      data[min] = tmp;
   }
   for (int i = 0; i < size; i++) {
      printf("%d : ", data[i]);
   }
   printf("\n");


}   


/////////////////////////////////////////////////////////////////////////////

선택정렬
#include <stdlib.h>
int* sel_sort(int data_ori[], int size) {
   int* data = malloc(sizeof(int) * size);
   for (int i = 0; i < size; i++)
   {
      data[i] = data_ori[i];
   }

   //1. 가장 앞부터 순서대로 하나씩 선택
   for (int i = 0; i < size; i++)
   {
      //2. 선택된 값부터 가장 마지막 까지 중
      //가장 작은 값을 찾음
      int min = i;
      //가장 작은 값이 몇번째 값 인지
      for (int j = i; j < size; j++)
      {
         if (data[min] > data[j]) {
            min = j;
         }
      }
      //3. 찾은 값과 선택된 값을 서로 교환
      int tmp = data[min];
      data[min] = data[i];
      data[i] = tmp;
   }

   return data;
}

//////////////////////////////////////////////////////////////////////////
삽입정렬
#include <stdlib.h>

int* ins_sort(int data_ori[], int size) {
   int* data = malloc(sizeof(int) * size);
   for (int i = 0; i < size; i++)
   {
      data[i] = data_ori[i];
   }

   //0. 순서대로 하나씩 선택
   for (int i = 0; i < size; i++)
   {
      int key = data[i];
      //1. 이미 정렬되어 있는 값(선택된 값 앞의 값)들 중
      //가장 앞에 도달하기 전 까지 반복
      int j;
      for (j = i; j > 0; j--)
      {
         //2. 자기보다 크다면, 
         if (data[j - 1] > key) {
            //빈공간을 한 칸 앞으로 전진
            //원래 해당 공간에 있던 값을 뒤로 이동
            data[j] = data[j - 1];
         }
         else {
            //3. 자기보다 작다면 반복 종료
            break;
         }
      }
      //현재 빈공간에 선택한 값을 삽입
      data[j] = key;
   }

   return data;
}
/////////////////////////////////////////////////////////////////////////////
버블 정렬(Bubble Sort)
   작은 값이 하나씩 위로 떠오르는 모양으로 정렬
   순서대로 2값을 비교해서, 더 작은 값을 앞으로 위치

   0. 배열의 갯수만큼 반복
   1. 처음부터 끝(-횟수)까지 반복
   2. 현재값과 다음값을 비교
   3. 다음값이 더 작다면, 두 값의 위치를 변경

   시간 복잡도 : O(n^2)


퀵 정렬(Quick Sort)
   시간 복잡도 : O(n*log n)
   단, 최악의 경우 : O(n^2)

   가장 앞에 있는 수를 선택
   선택된 수 보다 작은 값은 왼쪽에
   선택된 수 보다 큰 값은 오른쪽에 모음
   이걸을 반복하면, 어떤 숫자를 선택해도
   선택된 수 보다 왼쪽에는 작은 수만
   선택된 수 보다 오른쪽에는 큰 수만 
   모여있게 됨
   즉, 정렬된 상태가 됨

   만약, 선택된 수가 가장 큰 수거나 가장 작은 수면 두 부분으로 나눠지지 않기 때문에
   n*n의 시간 복잡도를 가지게 됨(이미 정렬되어 있는 경우가 대표적)

실제 구현
   구현 .1
      선택 되는 수는 분할된 배열 중 가장 앞
   구현 .2
      왼쪽 부터 오른쪽으로 이동하는 커서 와
      오른쪽부터 왼쪽으로 이동하는 커서를 
      하나씩 두고

      왼쪽 커서는 왼쪽에 와도 되는 수 인지를 검사(즉 선택된 값 보다 작은 지 검사)
      오른쪽 커서는 오른쪽에 있어도 되는지를 검사(즉 선택된 값 보다 큰 지를 검사)
   구현 .3
      1, 2 등 작업을 마치고 나면 2개로 분할
      각 분할 별로 별도로 같은 작업을 수행
      이를 위해 재귀함수 사용

   실제 구현
   1. 현재 범위 중 가장 앞의 값을 선택
   2. 선택된 값을 제외하고 가장 앞의값의 위치(선택값 뒤)l
   범위중 가장 뒤의 값의 위치를 r 로
   3. 왼쪽 커서는 선택된 값 보다 큰 값을 만날때까지 진행
   4. 오른쪽 커서는 선택된 값 보다 작은 값을 만날때까지 진행
   5. 오른쪽 커서의 값과 왼쪽 커서의 값을 서로 교체
   6. 만약, 두 커서가 서로 교차했거나, 범위를 벗어나면
   오른쪽 커서가 가르키는 위치와 선택된 값을 교체
   1-6을 반복하되, 선택된 값의 현재 위치 기준으로
   나뉜 두 부분을 별도로 반복
           
(데이터가 1개 이하이면 반복하지 않음 )
(end - start <=0 이면 반복하지 않음)
   연습 
   7 5 2 6 9 10 0 1 15 20


